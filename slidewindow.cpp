// 滑动窗口的思想:
// (1) 初始时，i = 0, j = 0;这是窗口的左右指针。
// (2) j开始向右移动一个位置，这个时候要问这个元素A[j]的加入是否导致窗口不满足要求，如果是的，则要不断地向右移动i，直到窗口符合要求，或i追上j。否则不处理
// (3) 重复（2）,直到系列遍历结束。
// 这里面有几个问题是需要注意：
// (1) 题目往往是需要求最值，这个最值就在窗口每次变动中求,即求所有变动的窗口中最优的一个。
// (2) 每次j移动的时候，就带来一个可能不符合窗口的问题，就需要一个循环不断的移动i来判断窗口是否符合要求，这个复杂度需要被优化。
// (3) 为什么加入了一个A[j]导致窗口不符合要求，就要把循环移动i直到符合要求？这是滑动的基本思想决定的，需要仔细体会。
// (4) 滑动窗口的时间复杂度比O(n^2)小，基本是O(n * m) m是窗口最大size。

// 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。
// 输入: "abcabcbb"
// 输出: 3 
// 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

public:
    int lengthOfLongestSubstring(string s) {
        int i = 0, j = 0, m = 1;
        // 用来判断一个字符是否已经在窗口中
        vector<int> ciw(26, 0);
        for (int k = 0; k < s.size(); k++) {
            char c = s[j];
            ciw[s[j] - 'a']++;
            while (ciw[s[j] - 'a'] > 1 && i < j) {
                ciw[s[i] - 'a']--;
                i++;
            }
            m = max(m, j - i + 1);
            j++;
        }
        return m;
    }
};
